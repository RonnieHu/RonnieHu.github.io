<!DOCTYPE HTML>
<html lang="">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->





<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->


<title>数据结构与算法知识体系 | Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/javascript.png">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  style="background-image:url(http://ronniehu.oss-cn-beijing.aliyuncs.com/banner.jpg)"  >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='Ronnie Hu'>
            <img src="/img/zero.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>
            
                 <img src="/img/slogan.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/Web/"><i class="fa "></i>Web</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/工具/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/综合/"><i class="fa "></i>综合</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/tags/随笔/"><i class="fa "></i>随笔</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="数据结构与算法知识体系">
            
	            数据结构与算法知识体系
            
        </h1>
        <div class="post-meta">
    
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a href="/categories/ ">
             
        </a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
                
                    <a href="/tags/综合" title='综合'>
                        综合
                    </a>
                
            
        </span>
    </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/12/20</span>
        </span>
    
</div>

            
            
    </div>
    
    <div class="post-body post-content">
        <p>程序设计 = 数据结构 + 算法;</p>
<h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul>
<li>数据是描述客观事物的符号，是计算机可以操作的对象，是能被计算机识别并输入给计算机处理的符号集合。</li>
<li>数据对象是性质相同的数据元素的集合，是数据的子集，在不混淆的情况下，将数据对象简称为数据。</li>
<li><strong>数据结构是相互之间存在一种或多种特定关系的数据元素的集合。</strong></li>
<li>数据元素是组成数据的有一定意义的基本单位，在计算机通常作为整体处理，也被称为记录。</li>
<li>数据项是数据不可分割的最小单位，一个数据元素可以由若干个数据项构成。</li>
</ul>
<p><img src="http://ronniehu.oss-cn-beijing.aliyuncs.com/data.png" alt="data"></p>
<p>数据结构可以分为逻辑结构和物理结构。逻辑结构是指数据对象中数据元素之间的关系，分为集合关系、线性关系、树形关系、图形结构；物理结构指数据的逻辑结构在计算机中的存储形式，分为顺序存储和链式存储。</p>
<p><img src="http://ronniehu.oss-cn-beijing.aliyuncs.com/structure.png" alt="structure"></p>
<p>抽象数据类型(ADT)是指一个数学模型以及定义在此数学模型上的一组操作。如堆、栈、队列等。</p>
<blockquote>
<p>C语言按取值不同，数据类型可以分为原子类型和结构类型。原子类型包括整型、字符型、等；结构类型由若干个类型组成，是可以再分解的。</p>
</blockquote>
<p><strong>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每个指令表示一个或多个操作。</strong>算法具有输入、输出、有穷性、确定性和可行性的特性。算法设计应满足正确性、可读性、健壮性、时间效率高和存储量低的设计准则。</p>
<p>算法的度量方法：事后统计方法(不准确)和事前分析估算方法。</p>
<p><img src="http://ronniehu.oss-cn-beijing.aliyuncs.com/O%28%29.jpg" alt="O()"></p>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>
<blockquote>
<p>对数阶：while(count &lt; n) { count = count * 2 } =&gt; 2^x = n, 即x=logn。</p>
</blockquote>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表：零个或多个相同类型元素的有限序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ADT List</span><br><span class="line">Data</span><br><span class="line">    线性表的数据集合&#123;a1, a2, a3, ..., an&#125;，每一个元素的类型都是DataType</span><br><span class="line">    除了第一个元素a1外，每个元素只有一个直接前驱元素；除了最后一个元素an外，每个元素只有一个直接后继元素</span><br><span class="line">    数据元素之间的关系为一对一的关系</span><br><span class="line">Operation</span><br><span class="line">    InitList(*L);       创建空表</span><br><span class="line">    ListEmpty(L);       若线性表为空则返回true，否则返回false</span><br><span class="line">    clearList(*L);      将线性表清空</span><br><span class="line">    GetElem(L, i, *e);  将线性表中第i个元素返回给e</span><br><span class="line">    LocateElem(L, e);   在线性表中查找值为e的元素，如果查找成功，返回该元素的序列号</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p><strong>顺序存储结构</strong><br>顺序存储元素的位置公式为LOC(ai) = LOC(a1) + (i-1)*c，故顺序存储线性表存入或取出数据对计算机来说都是相等的时间，我们把具备这一特点的存储结构称之为随机存取结构。</p>
<p>线性表顺序存储结构优点：无需为表中元素之间的逻辑关系增加额外的存储空间；可以快速的存取表中某一元素，复杂度O(1)。<br>线性表顺序存储结构缺点：插入和删除操作需要移动大量元素，复杂度O(n)；当线性表长度长度大小变化较大时，难以确定存储空间容量；造成存储空间的碎片。<br><strong>链式存储结构</strong><br>我们把存储数据元素的域称为数据域，把存储直接后继位置的域称为指针域。这两部分信息组成的数据元素ai的存储映像称为结点。</p>
<p>我们把链表中第一个结点的存储位置称为头指针，常用头指针冠以链表名；而链表的最后一个结点指针为空，用NULL或^表示。无论链表是否为空，头指针始终不空。</p>
<p>有时我们为了方便操作，会在第一个结点之前设立一个头结点，头结点可以不存储任何信息，也可以存储线性表长度等信息。有了头结点，对第一结点插入删除结点的操作就与插入删除其他结点的操作一致了。链表空时头结点指针域为NULL。<br>单链表的优缺点：单链表的查找复杂度为O(n)，在找到某位置后插入和删除的复杂度为O(1)。</p>
<p><img src="http://ronniehu.oss-cn-beijing.aliyuncs.com/list-comp.png" alt="List-Comp"><br>若线性表需要大量读写操作或知道元素的大致个数，应使用顺序存储结构；若线性表需要大量增删操作或不知道元素个数或元素个数变化很大，应使用单链表。</p>
<p>我们把用数组描述的链表称为静态链表；把尾指针指向头结点或第一结点的链表称为循环链表；把每个结点都有两个分别指向前驱和后继指针的链表称为双向链表。</p>
<p><img src="http://ronniehu.oss-cn-beijing.aliyuncs.com/ls.png" alt="ls"></p>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><p><strong>栈</strong></p>
<p>栈是限定仅在表尾进行插入和删除操作的<strong>线性表</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈(stack)</span><br><span class="line">Data</span><br><span class="line">    同线性表。</span><br><span class="line">Operation</span><br><span class="line">    InitStack(*S)       初始化一个空栈</span><br><span class="line">    DestroyStack(*S)    若栈存在，则销毁栈</span><br><span class="line">    ClearStack(*S)      将栈清空</span><br><span class="line">    StackEmpty(S)       若栈为空返回true，否则返回false</span><br><span class="line">    GetTop(S, *e)       若栈存在，用e返回S的栈顶元素</span><br><span class="line">    Push(*S, e)         若栈存在，插入新元素e到栈S并成为栈顶元素</span><br><span class="line">    Pop(*S, *e)         删除栈顶元素，并用e返回其值</span><br><span class="line">    StackLength(S)      返回栈S的元素个数  </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>栈的顺序存储采用数组存储栈的元素，需考虑栈的大小，可能会造成存储空间的浪费，也可以用两栈共享空间扩展栈的大小(通常用作一个栈扩大，另一个栈减小的情况)。栈的链式存储简称链栈，没有栈的大小的顾虑，但是指针域的存在会增加内存开销。链栈和顺序栈的进栈出栈操作复杂度均为O(1)。</p>
<p>故栈的大小变化很大或不确定应该使用链栈，栈的大小变化在可控范围应该使用顺序栈。栈可以应用在历史记录，递归，四则预算表达式求值(中缀表达式转后缀表达式)等场景。</p>
<p><strong>队列</strong></p>
<p>队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT</span><br><span class="line">Data</span><br><span class="line">    同线性表</span><br><span class="line">Operation</span><br><span class="line">    InitQueue(*Q)</span><br><span class="line">    DestoryQueue(*Q)</span><br><span class="line">    ClearQueue(*Q)</span><br><span class="line">    QueueEmpty(Q)</span><br><span class="line">    GetHead(Q, *e)</span><br><span class="line">    EnQueue(*Q, e)</span><br><span class="line">    DeQueue(*Q, *e)</span><br><span class="line">    QueueLength(Q)</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>对于顺序队列，为了避免数组插入和删除时移动数据，于是引入了循环队列，使得队头和队尾可以在数组中循环变化，插入和删除的复杂度降为O(1)。<br>链队列为了操作方便，我们将队头指针指向链队列的头结点，而队尾指针指向终结点。<br>在可以确定队列长度最大值的情况下，使用循环队列；在无法预估队列长度时，使用链队列。</p>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串是由零个或多个字符组成的有限序列，又名字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT string(串)</span><br><span class="line">Data</span><br><span class="line">    串中元素仅由一个字符组成，相邻元素有前驱和后继的关系。</span><br><span class="line">Operation</span><br><span class="line">    StrAssign(T, *chars)    生成一个值为字符串常量chars的串T</span><br><span class="line">    StrCopy(T, S)           串S存在，由串S复制得到串T</span><br><span class="line">    ClearString(S)          </span><br><span class="line">    StringEmpty(S)</span><br><span class="line">    StrLength(S)</span><br><span class="line">    StrCompare(S, T)        若S&gt;T返回值大于0，若S&lt;T返回值小于0，若S=T返回值等于0</span><br><span class="line">    Concat(T, S1, S2)      </span><br><span class="line">    SubString(Sub, S, pos, len) </span><br><span class="line">    Index(S, T, pos)</span><br><span class="line">    Replace(S, T, V)</span><br><span class="line">    StrInsert(S, pos, T)</span><br><span class="line">    StrDelete(S, pos, len)</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>KMP模式匹配算法：用于正则表达式等字符串操作，相较朴素模式匹配，复杂度更低，执行更高效。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是n个结点的有限集合。当n=0时称为空树。在任意一棵非空树中：1)有且仅有一个特定的称为根(root)的结点；2)当n&gt;1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2、…、Tm，其中每一个集合本身又是一棵树，并称为根的子树。</p>
<p>结点拥有的子树数称为结点的度，度为0的结点称为叶子结点；树中结点的最大层数称为树的深度；如果树中结点的各子树看成从左向右是有次序的，不能互换，则称该树为有序树，否则称为无序树；森林是m棵互不相交的树的集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ADT 树</span><br><span class="line">Data</span><br><span class="line">    树是由一个根结点和若干个子树构成。树中结点具有相同的数据类型及层次关系。</span><br><span class="line">Operation</span><br><span class="line">    InitTree(*T)    </span><br><span class="line">    DestroyTree(*T)</span><br><span class="line">    CreateTree(*T, definition)  按definition中给出树的定义来构造树</span><br><span class="line">    ClearTree(*T)</span><br><span class="line">    TreeEmpty(T)</span><br><span class="line">    TreeDepth(T)</span><br><span class="line">    Root(T)</span><br><span class="line">    Value(T, cur_e) cur_e是树T中一个结点，返回此结点的值</span><br><span class="line">    Assign(T, cur_e, value)</span><br><span class="line">    Parent(T, cur_e)</span><br><span class="line">    LeftChild(T, cur_e)</span><br><span class="line">    RightSibling(T, cur_e)</span><br><span class="line">    InsertChild(*T, *p, i, c)   其中p指向树T的某个结点，i为所指结点p的度加1，非空树c与T                             不相交，操作结果为插入c为树T所指结点的第i棵子树</span><br><span class="line">    Delete(*T, *p, i)   其中p指向树T的某个结点，i为所指结点p的度，操作结点为删除T中p所指                     结点的第i棵子树  </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>树的表示法：双亲表示法(每个结点除了知道自己是谁，还知道它的双亲在哪里[顺序存储])/孩子表示法(每个结点有多个指针域，其中每个指针指向一棵子树的根结点，也称为多重链表表示法[链式存储])/孩子兄弟表示法(每个结点设置两个指针，一个指向该结点第一个孩子，一个指向此结点的右兄弟结点，这就将该树转化成了二叉树[链式存储])</p>
<p>线性表可以看做是树的一种极特殊表达形式。</p>
<p>二叉树：每个结点最多有两棵子树，所以二叉树不存在度大于2的结点，左子树与右子树有顺序，次序不能颠倒。<br>对一棵具有n个结点的二叉树按层序编号，如果编号n的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，这棵树称为完全二叉树。</p>
<ul>
<li>二叉树的第i层至多有2^(i-1)个结点；</li>
<li>深度为k的二叉树至多有2^k-1个结点；对于任意一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则n0=n2+1；</li>
<li>具有n个结点的完全二叉树的深度为|logn+1|(其中对数项以2为底)；</li>
<li>如果对于一棵有n个结点的完全二叉树的结点按层序编号(从第一层到第k层，每层从左向右)，对于任意结点i有：1)如果i=1，i是root，如果i&gt;1，其双亲是结点；2)如果2i&gt;n，则结点i无左孩子(结点i为叶子结点)，否则其左孩子是结点2i；3)如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li>
</ul>
<p>二叉树的顺序存储比较容易，如果是完全二叉树，按层序录入，如果非完全二叉树，空结点用NULL补齐后按层序录入。<br>二叉树的链式存储结构通常为每个结点设置了一个数据域和两个指针域(指向左子结点和右子结点)，称这样的链表为二叉链表。如果再加上指向双亲的指针域，则称为三叉链表。</p>
<p>二叉树的遍历：</p>
<ol>
<li>前序遍历：先访问根结点，然后遍历左子树，再遍历右子树。(自根结点，左右)</li>
<li>中序遍历：中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树。(自最左侧结点，左中右)</li>
<li>后续遍历：从左到右先叶子后结点的顺序遍历访问左右子树，最后访问根结点。(自最左侧结点，左右中)</li>
<li>层序遍历：从第一层到第k层，每层从左向右。<br>已知任意一种遍历方式加中序遍历方式可以得到另一种遍历方式，而知道前序遍历和后序遍历不能得到中序遍历方式。</li>
</ol>
<p>线索二叉树：我们把指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树即线索二叉树。如果实际应用中某二叉树经常需要遍历或查找结点的前驱、后继，那么线索二叉树是不错的选择。</p>
<p>判断一棵二叉树能够转化成为一棵树还是森林，只需要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。</p>
<p>假设有n个权值{w1, w2, w3, …, wn}构造一棵有n个叶子结点的二叉树，每个叶子结点带权wk，每个叶子的路径长度为lk，我们通常记作，其中带权路径长度WPL最小的二叉树称为霍夫曼树，也称为最优二叉树。</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V, E)，其中G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>若顶点vi到vj之间的边没有方向，则称这条边为无向边，用无序偶对(vi, vj)表示，如果图中任意两个顶点之间的边都是无向边，则称该图为无向图；若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧，用有序偶&lt; vi,vj &gt;来表示，vi称为弧尾(Tail)，vj称为弧头，如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。</p>
<p>在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图，含有n个顶点的无向完全图有n(n-1)/2条边；在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图，含有n个顶点的有向完全图有n×(n-1)条边。对于具有n个顶点和e条边数的图，无向图0≤e≤n(n-1)/2，有向图0≤e≤n(n-1)。<br>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权，这些权可以表示从一个顶点到另一个顶点的距离或耗费，这种带权的图通常称为网。</p>
<p>对于无向图G=(V,{E})，如果边(v,v’)∈E，则称顶点v和v’互为邻接点，即v和v’相邻接，边(v,v’)依附于顶点v和v’，或者说(v,v’)与顶点v和v’相关联，顶点v的度是和v相关联的边的数目，记为TD(v)；对于有向图G=(V,{E})，如果弧&lt; v,v’&gt;∈E，则称顶点v邻接到顶点v’，顶点v’邻接自顶点v，弧&lt; v,v’&gt;和顶点v，v’相关联，以顶点v为头的弧的数目称为v的入度，记为ID(v)，以v为尾的弧的数目称为v的出度，记为OD(v)，顶点v的度为TD(v)=ID(v)+OD(v)。</p>
<p>在无向图G中，如果从顶点v到顶点v’有路径，则称v和v’是连通的，如果对于图中任意两个顶点vi、vj∈V，vi和vj都是连通的，则称G是连通图，无向图的极大联通子图称为联通分量；在有向图G中，如果对于每一对vi、vj∈V、vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图，有向图中的极大强连通子图称做有向图的强连通分量。</p>
<p>所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶点，但只有足以构成一棵树的n-1条边；如果一个有向图恰有一个顶点的入度为0，其余顶点的入度均为1，则是一个有向树，对有向树的理解比较容易，所谓入度为0其实就相当于树中的根结点，其余顶点入度为1就是说树的非根结点的双亲只有一个，一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。</p>
<p>在图中，若不存在顶点到自身的边，并且同一条边不重复出现，称这样的图为简单图(数据结构只研究简单图)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT 图</span><br><span class="line">Data</span><br><span class="line">    顶点的有穷非空集合和边的集合</span><br><span class="line">Operation</span><br><span class="line">    CreateGraph(*G, V, VR)</span><br><span class="line">    DestroyGraph(*G)</span><br><span class="line">    LocateVex(G, u)         检验G是否有顶点u，如果有则返回图的位置</span><br><span class="line">    GetVex(G, u)            返回G中顶点u的值</span><br><span class="line">    PutVex(G, v, value)     将图中顶点v赋值给value</span><br><span class="line">    FirstAdjVex(G, *v)      返回顶点v的第一个邻接顶点</span><br><span class="line">    NextAdjVex(G, v, *w)    返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接顶点则返回空</span><br><span class="line">    InsertVex(*G, v)</span><br><span class="line">    DeleteVex(*G, v)</span><br><span class="line">    InsertArc(*G, v, w)     在图中添加弧&lt; v, w &gt;，若图是无向图，还需添加对称弧&lt; w, v &gt;</span><br><span class="line">    DeleteArc(*G, v, w)</span><br><span class="line">    DFSTraverse(G)          深度优先遍历</span><br><span class="line">    HFSTraverse(G)          广度优先遍历</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure>
<p>图的存储方式：</p>
<ul>
<li>图的邻接矩阵存储方式是用两个数组表示图，一个一维数组表示存储图中顶点信息，一个二维数组(称为邻接矩阵)存储图中的边或弧的信息。</li>
<li>图的邻接表表示法指图中顶点用一个一维数组表示，每个数组元素内存储指向第一个邻接点的指针，图中每个顶点vi的所有邻接点由于个数不确定，用一个链式存储的线性表表示。</li>
<li>图的十字链表存储方式整合了邻接表和逆邻接表，在有向图中是一种很好的存储方式。</li>
<li>图的邻接多重表存储方式优化了图的无向表的存储。</li>
<li>边集数组是由两个一维数组组成，一个存储顶点信息，另一个存储边的信息(每个数据元素由一条边的起点下标、终点下标和权组成)。</li>
</ul>
<p>从图的某顶点出发遍历图中其余顶点，且使每个顶点只被遍历一次，这一过程叫做图的遍历。遍历分为深度优先遍历(类似于树的前序遍历)和广度优先遍历(类似于树的层序遍历)。</p>
<p>最小生成树/最短路径/拓扑排序/关键路径 是图的衍生问题与算法解决方案。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找表是同一类数据元素构成的集合，按操作方式可分为静态查找(仅检索元素)和动态查找(会增删元素)。</p>
<p>顺序查找又称线性查找，它会从表中第一个元素开始查找给定值直到表尾。</p>
<p>折半查找又称二分查找，其前提必须是关键码有序且为顺序存储，其基本思想是在有序表中取中间记录作为比较对象，若与给定值相等则查找成功，若小于给定值则在中间记录的左半区继续比对其中间记录，若大于给定值则在中间记录的右半区继续比其中间记录，以此类推，直到找到值则查找成功，找不到则查找失败。<br>插值查找是折半查找的一种优化，是根据要查找的关键字与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式(key - a[low])/(a[high] - a[low])<br>斐波那契查找是折半查找的另一种优化，根据斐波那契数列确定查找区间。</p>
<p>索引按照结构可以分为线性结构、树形结构和多级索引，其中线性索引就是将索引项集合组织为线性结构，也称索引表。常见线性索引有稠密索引(将数据集的每一个记录对应一个索引项)、分块索引(将数据集的记录分为若干块，每块对应一个索引)和倒排索引(记录号表存储相同次关键字的所有记录的记录号，并根据需要属性的值来查找记录，典型应用于搜索引擎)。</p>
<p>二叉排序树又称二叉查找树/二叉搜索树，其左子树结点始终小于根结点的值，右子树结点始终大于根结点的值，其左右子树也是二叉排序树，对二叉排序树中序遍历即可得到一个有序的序列，构造二叉排序树提高了查找和插入删除关键字的速度。<br>平衡二叉树(AVL树)是一种优化的二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1，我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF，那么平衡二叉树上所有结点的平衡因子只可能是-1、0和1。平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。BF值为正，因此我们将整个树进行右旋(顺时针旋转)，BF是负值，所以我们对这棵最小平衡子树进行左旋(逆时针旋转)。</p>
<p>多路查找树其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。<br>B树是一种平衡的多路查找树，结点最大的孩子数目称为B树的阶。<br>B+树是应文件系统所需而出的一种B树的变形树，在B树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者(叶子结点)中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。B+树的结构特别适合带有范围的查找。</p>
<p>散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。查找时，根据这个确定的对应关系找到给定值key的映射f(key)，若查找集合中存在这个记录，则必定在f(key)的位置上。这里我们把这种对应关系f称为散列函数，又称为哈希函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表(Hash table)。那么关键字对应的记录存储位置我们称为散列地址。<br>散列函数的构造方法有：直接定址法(f(key)=a×key+b)、数字分析法、平方取中法、折叠法、除留余数法(最常用)、随机数法。<br>处理散列冲突的方法有：开放定址法、再散列函数法、链地址法、公共溢出区法。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>冒泡排序、简单选择排序、直接插入排序属于简单排序，希尔排序、堆排序、归并排序、快速排序属于改进算法。</p>
<p>冒泡排序的基本思想是两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录位置，时间复杂度为O(n^2)。</p>
<p>选择排序的基本思想是每次在n-i+1个记录中选取关键字最小的记录作为有序序列的第i个记录，其时间复杂度为O(n^2)。</p>
<p>插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数加1的有序表，其时间复杂度为O(n^2)。</p>
<p>希尔排序的基本思想是将相距某个增量的记录组成一个子序列，这样能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</p>
<p>堆是指每个结点的值都大于或小于其左右孩子结点的值的完全二叉树。堆排序的基本思想是将待排序的序列构造一个大顶堆，此时整个序列的最大值就是堆顶的根结点，将根结点移走后将剩余的n-1个序列重新构造成一个堆，这样就得到n个元素中的次大值，如此反复执行，就得到了一个有序队列，堆排序的时间复杂度为O(nlogn)。</p>
<p>归并排序的原理是假设初始序列含有n个记录，则可以看成n个有序的子序列，每个序列的长度为1，然后两两归并，得到|n/2|个长度为1或2的有序序列，再两两归并，如此重复，直到得到一个长度为n的有序序列为止，这种排序称为2路归并排序，其时间复杂度为O(nlogn)。</p>
<p>快速排序的基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的，其时间复杂度为O(nlogn)。</p>

    </div>

    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/16/深入认识JVM与GC/" class="pre-post btn btn-default" title='深入认识JVM&GC'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">深入认识JVM&GC</span>
        </a>
    
    
        <a href="/2018/12/03/探索Linux系统/" class="next-post btn btn-default" title='探索Linux系统'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">探索Linux系统</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
    
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构与算法"><span class="toc-text">数据结构与算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表"><span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈与队列"><span class="toc-text">栈与队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串"><span class="toc-text">串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-text">树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图"><span class="toc-text">图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找"><span class="toc-text">查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12"> 
                <span>Copyright &copy; 2017
                </span> | 
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> | 
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>


</body>
</html>